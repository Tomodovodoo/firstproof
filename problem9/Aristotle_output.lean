/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b2c7c4be-1c3d-4dbf-97e6-2199fe9c95e6

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for Problem 9.
-/
open Matrix BigOperators

variable {n : ℕ}

abbrev RowIndex (n : ℕ) := Fin n × Fin 3

abbrev Cameras (n : ℕ) := Fin n → Matrix (Fin 3) (Fin 4) ℝ

noncomputable def Q (A : Cameras n) : RowIndex n → RowIndex n → RowIndex n → RowIndex n → ℝ :=
  fun p q r s =>
    let row (x : RowIndex n) := A x.1 x.2
    det (of ![(row p), (row q), (row r), (row s)])

abbrev Lambda (n : ℕ) := Fin n → Fin n → Fin n → Fin n → ℝ

noncomputable def T (A : Cameras n) (L : Lambda n) : RowIndex n → RowIndex n → RowIndex n → RowIndex n → ℝ :=
  fun p q r s => L p.1 q.1 r.1 s.1 * Q A p q r s

noncomputable def Unfolding1 (X : RowIndex n → RowIndex n → RowIndex n → RowIndex n → ℝ) : Matrix (RowIndex n) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun p (q, r, s) => X p q r s

noncomputable def Unfolding2 (X : RowIndex n → RowIndex n → RowIndex n → RowIndex n → ℝ) : Matrix (RowIndex n) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun q (p, r, s) => X p q r s

noncomputable def Unfolding3 (X : RowIndex n → RowIndex n → RowIndex n → RowIndex n → ℝ) : Matrix (RowIndex n) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun r (p, q, s) => X p q r s

noncomputable def Unfolding4 (X : RowIndex n → RowIndex n → RowIndex n → RowIndex n → ℝ) : Matrix (RowIndex n) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun s (p, q, r) => X p q r s

def Minors5x5Vanish {α β : Type*} [Fintype α] [Fintype β] (M : Matrix α β ℝ) : Prop :=
  ∀ (rows : Fin 5 → α) (cols : Fin 5 → β), det (M.submatrix rows cols) = 0

def F_vanishes (X : RowIndex n → RowIndex n → RowIndex n → RowIndex n → ℝ) : Prop :=
  Minors5x5Vanish (Unfolding1 X) ∧
  Minors5x5Vanish (Unfolding2 X) ∧
  Minors5x5Vanish (Unfolding3 X) ∧
  Minors5x5Vanish (Unfolding4 X)

def NotAllIdentical (α β γ δ : Fin n) : Prop :=
  ¬ (α = β ∧ β = γ ∧ γ = δ)

def IsFactorizable (L : Lambda n) : Prop :=
  ∃ u v w x : Fin n → ℝ,
    (∀ i, u i ≠ 0) ∧ (∀ i, v i ≠ 0) ∧ (∀ i, w i ≠ 0) ∧ (∀ i, x i ≠ 0) ∧
    ∀ α β γ δ, NotAllIdentical α β γ δ →
      L α β γ δ = u α * v β * w γ * x δ

def LambdaSupport (L : Lambda n) : Prop :=
  ∀ α β γ δ, L α β γ δ ≠ 0 ↔ NotAllIdentical α β γ δ

def ZariskiGeneric (n : ℕ) (property : Cameras n → Prop) : Prop :=
  ∃ (poly : MvPolynomial (Fin n × Fin 3 × Fin 4) ℝ),
    poly ≠ 0 ∧ ∀ A, MvPolynomial.eval (fun ((i, j, k) : Fin n × Fin 3 × Fin 4) => A i j k) poly ≠ 0 → property A

/-
Diagonal blocks of Q vanish.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Lemma_3_0 (A : Cameras n) (α : Fin n) (i j k l : Fin 3) :
  Q A (α, i) (α, j) (α, k) (α, l) = 0 := by
    unfold Q;
    -- Since there are only 3 rows in A α, any four rows must have at least two identical rows.
    have h_pigeonhole : i = j ∨ i = k ∨ i = l ∨ j = k ∨ j = l ∨ k = l := by
      grind;
    rcases h_pigeonhole with ( rfl | rfl | rfl | rfl | rfl | rfl ) <;> norm_num [ Matrix.det_succ_row_zero ];
    all_goals simp +decide [ Fin.sum_univ_succ, Fin.succAbove ] ; ring!;

/-
Rank of stacked cameras is at most 4.
-/
open Matrix BigOperators

variable {n : ℕ}

def Stacked (A : Cameras n) : Matrix (RowIndex n) (Fin 4) ℝ :=
  fun p k => A p.1 p.2 k

lemma rank_Stacked_le_4 (A : Cameras n) : (Stacked A).rank ≤ 4 := by
  apply le_trans (rank_le_card_width (Stacked A))
  simp

/-
Unfolding1 factorization.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def CofactorMatrix1 (A : Cameras n) : Matrix (Fin 4) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun k (q, r, s) =>
    let rows := ![(A q.1 q.2), (A r.1 r.2), (A s.1 s.2)]
    let M := of rows
    (-1)^(k : ℕ) * det (M.submatrix id (Fin.succAbove k))

lemma Unfolding1_eq_mul (A : Cameras n) :
  Unfolding1 (Q A) = Stacked A * CofactorMatrix1 A := by
    ext ⟨ i, j ⟩ ⟨ k, l, m ⟩;
    simp +decide [ Matrix.mul_apply, CofactorMatrix1 ];
    unfold Q Stacked Unfolding1; simp +decide [ Matrix.det_fin_three ] ;
    simp +decide [ Fin.sum_univ_succ, Matrix.det_succ_row_zero ] ; ring!

/-
Rank of Unfolding1 is at most 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_Unfolding1_le_4 (A : Cameras n) : (Unfolding1 (Q A)).rank ≤ 4 := by
  rw [Unfolding1_eq_mul]
  apply le_trans (rank_mul_le_left (Stacked A) (CofactorMatrix1 A))
  apply rank_Stacked_le_4

/-
Unfolding2 factorization.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def CofactorMatrix2 (A : Cameras n) : Matrix (Fin 4) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun k (p, r, s) =>
    let rows := ![(A p.1 p.2), (A r.1 r.2), (A s.1 s.2)]
    let M := of rows
    (-1)^(1 + k : ℕ) * det (M.submatrix id (Fin.succAbove k))

lemma Unfolding2_eq_mul (A : Cameras n) :
  Unfolding2 (Q A) = Stacked A * CofactorMatrix2 A := by
    ext q p_r_s; simp [Unfolding2, CofactorMatrix2];
    unfold Q Stacked CofactorMatrix2; simp +decide [ Matrix.mul_apply, Fin.sum_univ_succ ] ; ring;
    simp +decide [ Matrix.det_succ_row_zero, Fin.sum_univ_succ ] ; ring!

/-
Rank of Unfolding2 is at most 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_Unfolding2_le_4 (A : Cameras n) : (Unfolding2 (Q A)).rank ≤ 4 := by
  rw [Unfolding2_eq_mul]
  apply le_trans (rank_mul_le_left (Stacked A) (CofactorMatrix2 A))
  apply rank_Stacked_le_4

/-
Unfolding3 factorization.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def CofactorMatrix3 (A : Cameras n) : Matrix (Fin 4) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun k (p, q, s) =>
    let rows := ![(A p.1 p.2), (A q.1 q.2), (A s.1 s.2)]
    let M := of rows
    (-1)^(2 + k : ℕ) * det (M.submatrix id (Fin.succAbove k))

lemma Unfolding3_eq_mul (A : Cameras n) :
  Unfolding3 (Q A) = Stacked A * CofactorMatrix3 A := by
    unfold Unfolding3 CofactorMatrix3 Stacked;
    ext ⟨r1, r2⟩ ⟨p, q, s⟩; simp +decide [ Matrix.mul_apply, Matrix.det_succ_row_zero ] ; ring;
    unfold Q; norm_num [ Fin.sum_univ_succ, Matrix.det_succ_row_zero ] ; ring;
    simp +decide [ Fin.succAbove ] ; ring!

/-
Rank of Unfolding3 is at most 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_Unfolding3_le_4 (A : Cameras n) : (Unfolding3 (Q A)).rank ≤ 4 := by
  rw [Unfolding3_eq_mul]
  apply le_trans (rank_mul_le_left (Stacked A) (CofactorMatrix3 A))
  apply rank_Stacked_le_4

/-
Unfolding4 factorization.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def CofactorMatrix4 (A : Cameras n) : Matrix (Fin 4) (RowIndex n × RowIndex n × RowIndex n) ℝ :=
  fun k (p, q, r) =>
    let rows := ![(A p.1 p.2), (A q.1 q.2), (A r.1 r.2)]
    let M := of rows
    (-1)^(3 + k : ℕ) * det (M.submatrix id (Fin.succAbove k))

lemma Unfolding4_eq_mul (A : Cameras n) :
  Unfolding4 (Q A) = Stacked A * CofactorMatrix4 A := by
    unfold Unfolding4 CofactorMatrix4 Stacked;
    ext ⟨ s₁, s₂ ⟩ ⟨ p, q, r ⟩ ; simp +decide [ Q, Matrix.mul_apply, Matrix.det_succ_row_zero ] ; ring;
    simp +decide [ Fin.sum_univ_succ, Fin.succAbove ] ; ring

/-
Rank of Unfolding4 is at most 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_Unfolding4_le_4 (A : Cameras n) : (Unfolding4 (Q A)).rank ≤ 4 := by
  rw [Unfolding4_eq_mul]
  apply le_trans (rank_mul_le_left (Stacked A) (CofactorMatrix4 A))
  apply rank_Stacked_le_4

/-
Rank <= 4 implies 5x5 minors vanish.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_le_four_implies_minors_vanish {m k : Type*} [Fintype m] [Fintype k] (M : Matrix m k ℝ) :
  M.rank ≤ 4 → Minors5x5Vanish M := by
    intro hRank
    intro rows cols
    have hSubmatrix : Matrix.rank (M.submatrix rows cols) ≤ 4 := by
      refine' le_trans _ hRank;
      -- The rank of a submatrix is less than or equal to the rank of the original matrix.
      have h_submatrix_rank : ∀ (rows : Fin 5 → m) (cols : Fin 5 → k), Matrix.rank (Matrix.submatrix M rows cols) ≤ Matrix.rank M := by
        intro rows cols;
        -- The submatrix is obtained by selecting certain rows and columns from M, so its rank is less than or equal to the rank of M.
        have h_submatrix : ∃ (P : Matrix (Fin 5) m ℝ) (Q : Matrix k (Fin 5) ℝ), Matrix.submatrix M rows cols = P * M * Q := by
          use Matrix.of (fun i j => if j = rows i then 1 else 0), Matrix.of (fun i j => if i = cols j then 1 else 0);
          ext i j; simp +decide [ Matrix.mul_apply ] ;
        obtain ⟨ P, Q, hPQ ⟩ := h_submatrix; rw [ hPQ ] ; exact Matrix.rank_mul_le_left _ _ |> le_trans <| Matrix.rank_mul_le_right _ _;
      exact h_submatrix_rank rows cols;
    contrapose! hSubmatrix;
    have := Matrix.rank_mul_le ( M.submatrix rows cols ) ( M.submatrix rows cols ) ⁻¹;
    simp_all +decide [ isUnit_iff_ne_zero ];
    linarith

/-
T is a scaled version of Q.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma T_eq_scaled_Q (A : Cameras n) (L : Lambda n) (h : IsFactorizable L) :
  ∃ u v w x : Fin n → ℝ, ∀ p q r s : RowIndex n,
    T A L p q r s = u p.1 * v q.1 * w r.1 * x s.1 * Q A p q r s := by
      obtain ⟨ u, v, w, x, hu, hv, hw, hx, h ⟩ := h;
      use u, v, w, x;
      intro p q r s;
      by_cases h_cases : p.1 = q.1 ∧ q.1 = r.1 ∧ r.1 = s.1;
      · -- Since $p.1 = q.1 = r.1 = s.1$, we have $Q A p q r s = 0$ by Lemma 3.0.
        have h_Q_zero : Q A p q r s = 0 := by
          have h_diag : ∀ i j k l : Fin 3, Q A (s.1, i) (s.1, j) (s.1, k) (s.1, l) = 0 := by
            exact?;
          grind;
        unfold T; aesop;
      · exact h p.1 q.1 r.1 s.1 ( by unfold NotAllIdentical; aesop ) ▸ by unfold T; ring;

/-
Rank of scaled matrix is less than or equal to rank of original matrix.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_scaled_le (M : Matrix (RowIndex n) (RowIndex n × RowIndex n × RowIndex n) ℝ)
  (u : RowIndex n → ℝ) (v : RowIndex n × RowIndex n × RowIndex n → ℝ) :
  (Matrix.of (fun i j => u i * v j * M i j)).rank ≤ M.rank := by
    -- By definition of $D_u$ and $D_v$, we have $D_u * M * D_v = \text{of} (\fun i j => u i * v j * M i j)$.
    have h_diagonal : Matrix.of (fun i j => u i * v j * M i j) = Matrix.diagonal u * M * Matrix.diagonal v := by
      ext i j; simp +decide [ Matrix.mul_apply, mul_assoc ] ;
      simp +decide [ Matrix.diagonal, Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      ring;
    exact h_diagonal ▸ le_trans ( Matrix.rank_mul_le_left _ _ ) ( Matrix.rank_mul_le_right _ _ )

/-
Forward direction: Factorizable L implies F(T) = 0.
-/
open Matrix BigOperators

variable {n : ℕ}

theorem Forward_Direction (A : Cameras n) (L : Lambda n) :
  IsFactorizable L → F_vanishes (T A L) := by
    intro hL_factorizable
    obtain ⟨u, v, w, x, hu_nonzero, hv_nonzero, hw_nonzero, hx_nonzero, hL⟩ := hL_factorizable;
    -- By T_eq_scaled_Q, T is obtained from Q by scaling rows and columns.
    have hT_scaled : ∃ u' v' w' x' : RowIndex n → ℝ, ∀ p q r s, T A L p q r s = u' p * v' q * w' r * x' s * Q A p q r s := by
      use fun p => u p.1, fun q => v q.1, fun r => w r.1, fun s => x s.1;
      intro p q r s; by_cases h : p.1 = q.1 ∧ q.1 = r.1 ∧ r.1 = s.1 <;> simp_all +decide [ T ] ;
      · exact Or.inr ( by rw [ show p = ( s.1, p.2 ) by aesop, show q = ( s.1, q.2 ) by aesop, show r = ( s.1, r.2 ) by aesop, show s = ( s.1, s.2 ) by aesop ] ; exact Lemma_3_0 A _ _ _ _ _ );
      · exact Or.inl <| hL _ _ _ _ <| by unfold NotAllIdentical; aesop;
    obtain ⟨ u', v', w', x', hT_scaled ⟩ := hT_scaled;
    -- By rank_scaled_le, rank(Unfolding1(T)) <= rank(Unfolding1(Q)).
    have h_rank1 : (Unfolding1 (T A L)).rank ≤ (Unfolding1 (Q A)).rank := by
      have h_rank1 : (Unfolding1 (T A L)).rank ≤ (Matrix.of (fun i j => u' i * (v' j.1 * w' j.2.1 * x' j.2.2) * (Unfolding1 (Q A) i j))).rank := by
        field_simp;
        exact le_of_eq ( congr_arg Matrix.rank ( by ext i j; aesop ) );
      refine le_trans h_rank1 ?_;
      convert rank_scaled_le ( Unfolding1 ( Q A ) ) ( fun i => u' i ) ( fun j => v' j.1 * w' j.2.1 * x' j.2.2 ) using 1
    have h_rank2 : (Unfolding2 (T A L)).rank ≤ (Unfolding2 (Q A)).rank := by
      convert rank_scaled_le ( Unfolding2 ( Q A ) ) ( fun q => v' q ) ( fun p => u' p.1 * w' p.2.1 * x' p.2.2 ) using 1;
      congr! 2;
      ext i j; simp +decide [ hT_scaled, mul_assoc, mul_comm, mul_left_comm ] ;
      convert hT_scaled j.1 i j.2.1 j.2.2 using 1 ; ring!
    have h_rank3 : (Unfolding3 (T A L)).rank ≤ (Unfolding3 (Q A)).rank := by
      convert rank_scaled_le ( Unfolding3 ( Q A ) ) ( fun p => w' p ) ( fun p => u' p.1 * v' p.2.1 * x' p.2.2 ) using 1;
      congr! 2;
      ext; simp +decide [ hT_scaled, Unfolding3 ] ; ring;
      norm_num
    have h_rank4 : (Unfolding4 (T A L)).rank ≤ (Unfolding4 (Q A)).rank := by
      convert rank_scaled_le _ _ _ using 2;
      rotate_left;
      exact fun p => x' p;
      exact fun p => u' p.1 * v' p.2.1 * w' p.2.2;
      ext; simp +decide [ hT_scaled, mul_assoc, mul_comm, mul_left_comm ] ;
      convert hT_scaled _ _ _ _ using 1 ; ring!;
    exact ⟨ rank_le_four_implies_minors_vanish _ ( h_rank1.trans ( rank_Unfolding1_le_4 _ ) ), rank_le_four_implies_minors_vanish _ ( h_rank2.trans ( rank_Unfolding2_le_4 _ ) ), rank_le_four_implies_minors_vanish _ ( h_rank3.trans ( rank_Unfolding3_le_4 _ ) ), rank_le_four_implies_minors_vanish _ ( h_rank4.trans ( rank_Unfolding4_le_4 _ ) ) ⟩

/-
Generic properties for the reverse direction.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def Submatrix1 (A : Cameras n) (β γ δ : Fin n) : Matrix (RowIndex n) (Fin 3 × Fin 3 × Fin 3) ℝ :=
  fun p (j, k, l) => Q A p (β, j) (γ, k) (δ, l)

noncomputable def Submatrix2 (A : Cameras n) (α γ δ : Fin n) : Matrix (RowIndex n) (Fin 3 × Fin 3 × Fin 3) ℝ :=
  fun q (i, k, l) => Q A (α, i) q (γ, k) (δ, l)

noncomputable def Submatrix3 (A : Cameras n) (α β δ : Fin n) : Matrix (RowIndex n) (Fin 3 × Fin 3 × Fin 3) ℝ :=
  fun r (i, j, l) => Q A (α, i) (β, j) r (δ, l)

def SpanningCondition1 (A : Cameras n) : Prop :=
  (Stacked A).rank = 4 ∧
  ∀ β γ δ, ¬(β = γ ∧ γ = δ) → (Submatrix1 A β γ δ).rank = 4

def SpanningCondition2 (A : Cameras n) : Prop :=
  (Stacked A).rank = 4 ∧
  ∀ α γ δ, ¬(α = γ ∧ γ = δ) → (Submatrix2 A α γ δ).rank = 4

def SpanningCondition3 (A : Cameras n) : Prop :=
  (Stacked A).rank = 4 ∧
  ∀ α β δ, ¬(α = β ∧ β = δ) → (Submatrix3 A α β δ).rank = 4

def GenericProperties (A : Cameras n) : Prop :=
  (∀ α, (A α).rank = 3) ∧
  SpanningCondition1 A ∧
  SpanningCondition2 A ∧
  SpanningCondition3 A

/-
Block diagonal matrix definition.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def BlockDiagonal (s : Fin n → ℝ) : Matrix (RowIndex n) (RowIndex n) ℝ :=
  Matrix.diagonal (fun p => s p.1)

/-
Block-scalar stabilizer rigidity.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Lemma_4_2 (A : Cameras n) (s : Fin n → ℝ) :
  GenericProperties A →
  (∀ x : Fin 4 → ℝ, ∃ y : Fin 4 → ℝ, Matrix.mulVec (BlockDiagonal s) (Matrix.mulVec (Stacked A) x) = Matrix.mulVec (Stacked A) y) →
  ∀ α β, s α = s β := by
    intro hA h_eq α β;
    -- Since Stacked A has rank 4 (full column rank), the map x -> y is linear, so there exists R such that BlockDiagonal s * Stacked A = Stacked A * R.
    obtain ⟨R, hR⟩ : ∃ R : Matrix (Fin 4) (Fin 4) ℝ, BlockDiagonal s * Stacked A = Stacked A * R := by
      choose f hf using h_eq;
      use Matrix.of (fun i j => f ( Pi.single j 1 ) i);
      ext i j; specialize hf ( Pi.single j 1 ) ; replace hf := congr_fun hf i; aesop;
    -- Restricting to camera alpha, s(alpha) * A(alpha) = A(alpha) * R.
    have h_restrict : ∀ α : Fin n, s α • A α = A α * R := by
      intro α
      have h_restrict : ∀ p : RowIndex n, p.1 = α → (BlockDiagonal s * Stacked A) p = (Stacked A * R) p := by
        exact fun p hp => congr_fun hR p;
      ext i j; specialize h_restrict ( α, i ) rfl; simp_all +decide [ Matrix.mul_apply, BlockDiagonal ] ;
      replace hR := congr_fun ( congr_fun hR ( α, i ) ) j; simp_all +decide [ Matrix.mul_apply, Finset.sum_mul _ _ _ ] ;
      simp_all +decide [ Matrix.diagonal, Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      convert hR using 1;
    -- Thus the row space of A(alpha) is an invariant subspace of R^T with eigenvalue s(alpha).
    have h_invariant : ∀ α : Fin n, LinearMap.range (Matrix.mulVecLin (A α).transpose) ≤ LinearMap.ker (Matrix.mulVecLin (R.transpose - Matrix.diagonal (fun _ => s α))) := by
      intro α x hx; obtain ⟨ y, rfl ⟩ := hx; simp_all +decide [ ← Matrix.mul_assoc, Matrix.sub_mulVec ] ;
      simp +decide [ ← h_restrict α, Matrix.vecMul_smul ];
    -- Since rank(A(alpha)) = 3, the geometric multiplicity of s(alpha) is >= 3.
    have h_geometric_multiplicity : ∀ α : Fin n, Module.finrank ℝ (LinearMap.ker (Matrix.mulVecLin (R.transpose - Matrix.diagonal (fun _ => s α)))) ≥ 3 := by
      intro α
      have h_rank_A : Matrix.rank (A α) = 3 := by
        exact hA.1 α;
      have h_geometric_multiplicity : Module.finrank ℝ (LinearMap.range (Matrix.mulVecLin (A α).transpose)) ≥ 3 := by
        rw [ ← Matrix.rank ] at * ; aesop;
      exact le_trans h_geometric_multiplicity ( Submodule.finrank_mono ( h_invariant α ) );
    -- If s(alpha) != s(beta), we have two eigenspaces of dim >= 3 in R^4, sum of dims >= 6 > 4, contradiction.
    by_contra h_contra
    have h_eigenspaces : Module.finrank ℝ (LinearMap.ker (Matrix.mulVecLin (R.transpose - Matrix.diagonal (fun _ => s α)))) + Module.finrank ℝ (LinearMap.ker (Matrix.mulVecLin (R.transpose - Matrix.diagonal (fun _ => s β)))) ≤ 4 := by
      have h_eigenspaces : LinearMap.ker (Matrix.mulVecLin (R.transpose - Matrix.diagonal (fun _ => s α))) ⊓ LinearMap.ker (Matrix.mulVecLin (R.transpose - Matrix.diagonal (fun _ => s β))) = ⊥ := by
        simp_all +decide [ Submodule.eq_bot_iff ];
        intro x hx₁ hx₂; simp_all +decide [ sub_eq_iff_eq_add, funext_iff ] ;
      rw [ ← Submodule.finrank_sup_add_finrank_inf_eq ];
      rw [ h_eigenspaces, finrank_bot ] ; norm_num;
      exact le_trans ( Submodule.finrank_le _ ) ( by norm_num );
    linarith [ h_geometric_multiplicity α, h_geometric_multiplicity β ]

/-
Block-scalar stabilizer rigidity.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Lemma_4_2_Rigidity (A : Cameras n) (s : Fin n → ℝ) :
  GenericProperties A →
  (∀ x : Fin 4 → ℝ, ∃ y : Fin 4 → ℝ, Matrix.mulVec (BlockDiagonal s) (Matrix.mulVec (Stacked A) x) = Matrix.mulVec (Stacked A) y) →
  ∀ α β, s α = s β := by
    exact?

/-
Submatrix of T is scaled submatrix of Q.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def Submatrix1_T (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) : Matrix (RowIndex n) (Fin 3 × Fin 3 × Fin 3) ℝ :=
  fun p (j, k, l) => T A L p (β, j) (γ, k) (δ, l)

lemma Submatrix1_T_eq_mul (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  Submatrix1_T A L β γ δ = BlockDiagonal (fun α => L α β γ δ) * Submatrix1 A β γ δ := by
    -- By definition of Submatrix1_T and BlockDiagonal, we can expand the right-hand side.
    ext p jkl
    simp [Submatrix1_T, BlockDiagonal];
    exact?

/-
Definition of NotAllEqual3.
-/
open Matrix BigOperators

variable {n : ℕ}

def NotAllEqual3 (x y z : Fin n) : Prop := ¬ (x = y ∧ y = z)

/-
Rank of Submatrix1_T is 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Submatrix1_T_rank (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  (Submatrix1_T A L β γ δ).rank = 4 := by
    intro hL hgen hneq
    have h_submatrix1 : Matrix.rank (Submatrix1 A β γ δ) = 4 := by
      apply hL.2.1.2 β γ δ hneq
    have h_diag : Invertible (BlockDiagonal (fun α => L α β γ δ)) := by
      have h_diag_inv : ∀ α : Fin n, L α β γ δ ≠ 0 := by
        exact fun α => hgen α β γ δ |>.2 fun h => hneq ⟨ by aesop, by aesop ⟩;
      -- Since the diagonal entries of BlockDiagonal (fun α => L α β γ δ) are non-zero, the matrix is invertible.
      have h_diag_inv : Invertible (Matrix.diagonal (fun α : RowIndex n => L α.1 β γ δ)) := by
        convert Matrix.invertibleOfDetInvertible _;
        convert invertibleOfNonzero _ ; simp +decide [ h_diag_inv ];
        exact Finset.prod_ne_zero_iff.mpr fun α _ => h_diag_inv α.1;
      convert h_diag_inv using 1
    have h_submatrix1_T : Matrix.rank (Submatrix1_T A L β γ δ) = Matrix.rank (Submatrix1 A β γ δ) := by
      have h_submatrix1_T : Submatrix1_T A L β γ δ = BlockDiagonal (fun α => L α β γ δ) * Submatrix1 A β γ δ := by
        exact?
      rw [h_submatrix1_T];
      refine' le_antisymm _ _;
      · exact Matrix.rank_mul_le_right _ _;
      · have := Matrix.rank_mul_le ( ( BlockDiagonal fun α => L α β γ δ ) ⁻¹ ) ( ( BlockDiagonal fun α => L α β γ δ ) * Submatrix1 A β γ δ ) ; aesop;
    have h_rank : Matrix.rank (Submatrix1_T A L β γ δ) = 4 := by
      grind
    exact h_rank

/-
Rank of Submatrix1_T is 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Submatrix1_T_rank' (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  (Submatrix1_T A L β γ δ).rank = 4 := by
    exact?

/-
Block-scalar stabilizer rigidity.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Lemma_Rigidity (A : Cameras n) (s : Fin n → ℝ) :
  GenericProperties A →
  (∀ x : Fin 4 → ℝ, ∃ y : Fin 4 → ℝ, Matrix.mulVec (BlockDiagonal s) (Matrix.mulVec (Stacked A) x) = Matrix.mulVec (Stacked A) y) →
  ∀ α β, s α = s β := by
    convert Lemma_4_2_Rigidity A s using 1

/-
Rank equality implies column space equality.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Rank_eq_implies_ColumnSpace_eq {m k l : Type*} [Fintype m] [Fintype k] [Fintype l] [DecidableEq m] [DecidableEq k] [DecidableEq l]
  (M : Matrix m l ℝ) (S : Matrix m k ℝ)
  (h_sub : ∀ j, ∃ i, S.col j = M.col i)
  (h_rank_M : M.rank ≤ 4)
  (h_rank_S : S.rank = 4) :
  Submodule.span ℝ (Set.range S.col) = Submodule.span ℝ (Set.range M.col) := by
    refine' Submodule.eq_of_le_of_finrank_eq _ _;
    · exact Submodule.span_le.mpr ( Set.range_subset_iff.mpr fun j => by obtain ⟨ i, hi ⟩ := h_sub j; exact hi ▸ Submodule.subset_span ( Set.mem_range_self i ) );
    · have h_rank_M_eq : Module.finrank ℝ (Submodule.span ℝ (Set.range M.col)) ≤ 4 := by
        convert h_rank_M using 1;
        exact?;
      have h_rank_S_eq : Module.finrank ℝ (Submodule.span ℝ (Set.range S.col)) ≥ 4 := by
        rw [ ← h_rank_S, Matrix.rank ];
        rw [ show LinearMap.range S.mulVecLin = Submodule.span ℝ ( Set.range S.col ) from ?_ ];
        exact?;
      linarith [ show Module.finrank ℝ ( Submodule.span ℝ ( Set.range S.col ) ) ≤ Module.finrank ℝ ( Submodule.span ℝ ( Set.range M.col ) ) from Submodule.finrank_mono <| Submodule.span_le.mpr <| Set.range_subset_iff.mpr fun j => by obtain ⟨ i, hi ⟩ := h_sub j; aesop ]

/-
Range equality from rank equality and inclusion.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Range_eq_of_le_rank {m k l : Type*} [Fintype m] [Fintype k] [Fintype l] [DecidableEq m] [DecidableEq k] [DecidableEq l]
  (A : Matrix m k ℝ) (B : Matrix m l ℝ)
  (h_le : Submodule.span ℝ (Set.range A.col) ≤ Submodule.span ℝ (Set.range B.col))
  (h_rank_A : A.rank = 4)
  (h_rank_B : B.rank = 4) :
  Submodule.span ℝ (Set.range A.col) = Submodule.span ℝ (Set.range B.col) := by
    refine' Submodule.eq_of_le_of_finrank_eq h_le _;
    convert h_rank_A.trans h_rank_B.symm using 2;
    · exact?;
    · exact?

/-
Rank of Submatrix1_T is 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Submatrix1_T_rank_proof (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  (Submatrix1_T A L β γ δ).rank = 4 := by
    exact?

/-
Rank of Submatrix1_T is 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Submatrix1_T_rank_final (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  (Submatrix1_T A L β γ δ).rank = 4 := by
    exact?

/-
BlockDiagonal is invertible if s is nowhere zero.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma BlockDiagonal_invertible (s : Fin n → ℝ) (h : ∀ i, s i ≠ 0) :
  IsUnit (BlockDiagonal s).det := by
    convert isUnit_iff_ne_zero.mpr _ using 1;
    convert Matrix.det_ne_zero_of_left_inverse _ using 1;
    exact Matrix.diagonal fun i => ( s i.1 ) ⁻¹;
    · infer_instance;
    · ext ⟨ i, j ⟩ ⟨ k, l ⟩ ; simp +decide [ Matrix.one_apply, Matrix.mul_apply, h ];
      simp +decide [ Matrix.diagonal, BlockDiagonal, h ];
      aesop

/-
Rank of Submatrix1_T is 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Submatrix1_T_rank_correct (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  (Submatrix1_T A L β γ δ).rank = 4 := by
    exact?

/-
Rank of Submatrix1_T is 4.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Submatrix1_T_rank_v2 (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  (Submatrix1_T A L β γ δ).rank = 4 := by
    exact?

/-
Rank of Submatrix1_T is 4 (v3).
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Submatrix1_T_rank_v3 (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  (Submatrix1_T A L β γ δ).rank = 4 := by
    intro hA hL hneq
    rw [Submatrix1_T_eq_mul]
    have h_det : IsUnit (BlockDiagonal (fun α => L α β γ δ)).det := by
      apply BlockDiagonal_invertible
      intro α
      rw [hL]
      unfold NotAllIdentical
      unfold NotAllEqual3 at hneq
      intro h_eq
      apply hneq
      exact ⟨h_eq.2.1, h_eq.2.2⟩
    rw [Matrix.rank_mul_eq_right_of_isUnit_det _ _ h_det]
    exact hA.2.1.2 β γ δ hneq

/-
Column space of Submatrix1 is W.
-/
open Matrix BigOperators

variable {n : ℕ}

def W (A : Cameras n) : Submodule ℝ (RowIndex n → ℝ) :=
  Submodule.span ℝ (Set.range (Stacked A).col)

lemma Lemma_ColSpace_Submatrix1 (A : Cameras n) (β γ δ : Fin n) :
  GenericProperties A →
  NotAllEqual3 β γ δ →
  Submodule.span ℝ (Set.range (Submatrix1 A β γ δ).col) = W A := by
    -- By definition of Submatrix1, its columns are linear combinations of the columns of Q.
    intros hA hβγδ
    apply Eq.symm;
    have h_col_space : Submodule.span ℝ (Set.range (Submatrix1 A β γ δ).col) ≤ W A := by
      rw [ Submodule.span_le, Set.range_subset_iff ];
      intro y
      simp [W];
      -- By definition of Submatrix1, each column is a linear combination of the columns of Q.
      have h_col_comb : ∀ y : Fin 3 × Fin 3 × Fin 3, ∃ h : Fin 4 → ℝ, (Submatrix1 A β γ δ).col y = Matrix.mulVec (Stacked A) h := by
        intro y
        use fun k => (-1)^(k : ℕ) * det (Matrix.of ![A β y.1, A γ y.2.1, A δ y.2.2] |>.submatrix id (Fin.succAbove k));
        ext p; simp +decide [ Matrix.mulVec, dotProduct ] ;
        simp +decide [ Submatrix1, Stacked, Matrix.det_succ_row_zero ];
        unfold Q; simp +decide [ Matrix.det_succ_row_zero ] ; ring;
      obtain ⟨ h, hh ⟩ := h_col_comb y;
      rw [ hh ];
      rw [ Submodule.mem_span_range_iff_exists_fun ];
      exact ⟨ h, by ext i; simp +decide [ Matrix.mulVec, dotProduct, mul_comm ] ⟩;
    -- Since the rank of Submatrix1 A β γ δ is 4 and the dimension of W A is also 4, the subspaces must be equal.
    have h_dim_eq : Module.finrank ℝ (Submodule.span ℝ (Set.range (Submatrix1 A β γ δ).col)) = 4 ∧ Module.finrank ℝ (W A) = 4 := by
      constructor;
      · have h_rank_submatrix1 : (Submatrix1 A β γ δ).rank = 4 := by
          have := hA.2.1;
          unfold SpanningCondition1 at this; aesop;
        convert h_rank_submatrix1 using 1;
        exact?;
      · have := hA.2.1;
        convert this.1 using 1;
        unfold W;
        exact?;
    have := Submodule.eq_of_le_of_finrank_eq h_col_space; aesop;

/-
Column space of Submatrix1_T is D * W.
-/
open Matrix BigOperators

variable {n : ℕ}

noncomputable def D_triple (L : Lambda n) (β γ δ : Fin n) : Matrix (RowIndex n) (RowIndex n) ℝ :=
  BlockDiagonal (fun α => L α β γ δ)

def ColSpace {m n : Type*} [Fintype m] [Fintype n] (M : Matrix m n ℝ) : Submodule ℝ (m → ℝ) :=
  Submodule.span ℝ (Set.range M.col)

lemma Lemma_ColSpace_Submatrix1_T (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  GenericProperties A →
  LambdaSupport L →
  NotAllEqual3 β γ δ →
  ColSpace (Submatrix1_T A L β γ δ) = Submodule.map (Matrix.mulVecLin (D_triple L β γ δ)) (W A) := by
    intro hA hL hβγδ;
    -- By definition of $Submatrix1_T$, we know that its column space is the image of the column space of $Submatrix1$ under $D_triple$.
    have h_col_space : Submodule.span ℝ (Set.range (Submatrix1_T A L β γ δ).col) = Submodule.map (Matrix.mulVecLin (D_triple L β γ δ)) (Submodule.span ℝ (Set.range (Submatrix1 A β γ δ).col)) := by
      rw [ Submatrix1_T_eq_mul ];
      rw [ Submodule.map_span ];
      congr with x ; aesop;
    convert h_col_space using 1;
    rw [ Lemma_ColSpace_Submatrix1 A β γ δ hA hβγδ ]

/-
Column space inclusion.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma Lemma_Submatrix1_T_subset_Unfolding1 (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  ColSpace (Submatrix1_T A L β γ δ) ≤ ColSpace (Unfolding1 (T A L)) := by
    refine' Submodule.span_le.mpr _;
    rintro _ ⟨ j, rfl ⟩;
    -- The j-th column of Submatrix1_T is the same as the column of Unfolding1 indexed by ((β, j.1), (γ, j.2.1), (δ, j.2.2)).
    have h_col_eq : (Submatrix1_T A L β γ δ).col j = (Unfolding1 (T A L)).col ((β, j.1), (γ, j.2.1), (δ, j.2.2)) := by
      exact?;
    exact h_col_eq.symm ▸ Submodule.subset_span ( Set.mem_range_self _ )

/-
Rank monotonicity with respect to column space inclusion.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_le_of_colSpace_le {m k l : Type*} [Fintype m] [Fintype k] [Fintype l] [DecidableEq k] [DecidableEq l]
  (A : Matrix m k ℝ) (B : Matrix m l ℝ)
  (h : ColSpace A ≤ ColSpace B) :
  A.rank ≤ B.rank := by
    -- Since the column space of A is contained � in� the column space of B, their dimensions must satisfy the � inequality�.
    have h_dim : Module.finrank ℝ (↥(Submodule.span ℝ (Set.range A.col))) ≤ Module.finrank ℝ (↥(Submodule.span ℝ (Set.range B.col))) := by
      apply_rules [ Submodule.finrank_mono ];
    convert h_dim using 1;
    · exact?;
    · exact?

/-
Rank inequality for Submatrix1_T and Unfolding1.
-/
open Matrix BigOperators

variable {n : ℕ}

lemma rank_Submatrix1_T_le_rank_Unfolding1 (A : Cameras n) (L : Lambda n) (β γ δ : Fin n) :
  (Submatrix1_T A L β γ δ).rank ≤ (Unfolding1 (T A L)).rank := by
    apply rank_le_of_colSpace_le
    apply Lemma_Submatrix1_T_subset_Unfolding1